\section{Vectors and Positions}

Position vectors: Parametrize point $P$ in frame $\mathcal{A}$ as
${}_\mathcal{A}\mathbf{r}_{AP} = \mathbf{r}(\chi)$, where $\chi$
are parameters (e.g. $\chi = (x, y, z)^T$).

\subsection{Linear Velocity}

\[
  \mathbf{r} = \mathbf{r}(\chi), \quad \dot{\mathbf{r}} =
  \frac{\partial \mathbf{r}}{\partial \chi} \dot{\chi} =
  \mathbf{E}_p(\chi) \dot{\chi}
\]

\subsection{Rotations}

\textbf{Rotation matrix}
$\mathbf{C}_{\mathcal{A}\mathcal{B}}$ transforms
vectors from frame \( \mathcal{B} \) to \( \mathcal{A} \):
\[
  {}_\mathcal{A}\mathbf{r}_{AP} = \mathbf{C}_{\mathcal{A}\mathcal{B}}
  \cdot {}_\mathcal{B}\mathbf{r}_{AP}
\]
\textbf{Properties}
Orthogonal (\( \mathbf{C}^T = \mathbf{C}^{-1} \)),
det=1 for proper rotations

\textbf{Elementary rotations} (about x,y,z axes by angle \( \theta \)):
\[
  \mathbf{R}_x(\theta) =
  \begin{bmatrix} 1 & 0 & 0 \\ 0 & \cos\theta & -\sin\theta \\ 0 &
    \sin\theta & \cos\theta
  \end{bmatrix}
\]
\[
  \mathbf{R}_y(\theta) =
  \begin{bmatrix} \cos\theta & 0 & \sin\theta \\ 0 & 1 & 0
    \\ -\sin\theta & 0 & \cos\theta
  \end{bmatrix}
\]
\[
  \mathbf{R}_z(\theta) =
  \begin{bmatrix} \cos\theta & -\sin\theta & 0 \\ \sin\theta &
    \cos\theta & 0 \\ 0 & 0 & 1
  \end{bmatrix}
\]

\textbf{Composition}:
$\mathbf{C}_{\mathcal{A}\mathcal{C}}
= \mathbf{C}_{\mathcal{A}\mathcal{B}} \cdot \mathbf{C}_{\mathcal{B}\mathcal{C}}$

\textbf{Homogeneous transformations} (4x4 for position + orientation):
\[
  \mathbf{T}_{\mathcal{A}\mathcal{B}} =
  \begin{bmatrix} \mathbf{C}_{\mathcal{A}\mathcal{B}} &
    {}_\mathcal{A}\mathbf{r}_{AB} \\ \mathbf{0}_{1\times3} & 1
  \end{bmatrix}
\]

To apply: For point $\mathbf{p}$ in frame $n$, in frame 0: $
\begin{bmatrix} {}^0\mathbf{p} \\ 1
\end{bmatrix} = \mathbf{T}_{0n}
\begin{bmatrix} {}^n\mathbf{p} \\ 1
\end{bmatrix}$

\textbf{Passive}: Rotate frame\quad
\textbf{Active}: Rotate vector

\ssthl{Exam pitfall: Confuse active/passive in inverse kinematics}

\subsection{Angular Velocity}

Angular velocity $\boldsymbol{\omega}$ satisfies
$\dot{\mathbf{C}} = \boldsymbol{\omega} \times \mathbf{C}$,
or $\dot{\mathbf{C}} = \mathbf{S}(\boldsymbol{\omega}) \mathbf{C}$
\[
  \mathbf{S}(\mathbf{a}) =
  \begin{bmatrix} 0 & -a_z & a_y \\ a_z & 0 & -a_x \\ -a_y & a_x & 0
  \end{bmatrix}.
\]

\textbf{Composition}:
${}^\mathcal{A}\boldsymbol{\omega}_{\mathcal{A}\mathcal{C}} =
{}^\mathcal{A}\boldsymbol{\omega}_{\mathcal{A}\mathcal{B}} +
\mathbf{C}_{\mathcal{A}\mathcal{B}}
{}^\mathcal{B}\boldsymbol{\omega}_{\mathcal{B}\mathcal{C}}$

\ssthl{Exam note:
Use skew-symmetric for deriving velocity Jacobians}

\subsection{Parametrization of 3d Rotations}

\textbf{Minimal params} 3 - due to SO(3) manifold \\
Common for avoiding singularities in kinematics/control.\\
All parameterizations map to rotation matrix but differ in
singularities, redundancy, and computation.

\begin{itemize}[itemsep=0pt]
  \item \textbf{Rotation matrix}
    9 params, 6 orthonormality constraints.\\
    Direct but redundant.
    No singularities, but not minimal,
    used for storage/composition.
  \item \textbf{Euler angles} (e.g., ZYZ)
    $\mathbf{C} = \mathbf{R}_z(\phi) \mathbf{R}_y(\theta) \mathbf{R}_z(\psi)$
    \\
    3 params, singularities at $\theta = 0,\pi$ (gimbal lock)\\
    Variants: ZYX (roll-pitch-yaw), XYZ. Angular velocity:
    $\boldsymbol{\omega} = \mathbf{E}(\phi,\theta,\psi)
    \dot{\boldsymbol{\alpha}}$, where $\mathbf{E}$ is singular at gimbal lock.

  \item \textbf{Angle-axis} Rodrigues' formula:\\
    $\mathbf{C} = \exp(\mathbf{S}(\mathbf{k}\theta)) = \mathbf{I} +
    \sin\theta \mathbf{S}(\mathbf{k}) + (1-\cos\theta) \mathbf{S}^2(\mathbf{k})$
    \\
    $\mathbf{k}$ unit vector, $\theta \in [0,\pi]$.
    No singularities but multi-valued ($\theta=0$ ambiguous).
    Good for small rotations.

  \item \textbf{Rotation vector}
    $\boldsymbol{\rho} = \mathbf{k}\theta$
    \\
    Similar to angle-axis; exponential map from
    $\mathfrak{so}(3)$ to SO(3).\\ Velocity: $\boldsymbol{\omega} =
    \mathbf{T}(\boldsymbol{\rho}) \dot{\boldsymbol{\rho}}$, with
    $\mathbf{T}$ near-identity for small $\rho$.
  \item \textbf{Unit quaternions}: 4 params, 1 norm constraint
    ($\|\mathbf{q}\|=1$). No singularities, efficient for
    interpolation/composition. See dedicated subsection below.
\end{itemize}

\subsection{Unit Quaternions}

Standard definition: $\mathbf{q} = (q_0, \mathbf{q}_v) =
(\cos(\theta/2), \mathbf{k} \sin(\theta/2))$, where
$\|\mathbf{q}\|=1$, representing rotation by $\theta$ around unit
axis $\mathbf{k}$. Antipodal: $\mathbf{q} \equiv -\mathbf{q}$.

\textbf{To rotation matrix}:
\[
  \mathbf{C}(\mathbf{q}) = \mathbf{I} + 2 q_0
  \mathbf{S}(\mathbf{q}_v) + 2 \mathbf{S}^2(\mathbf{q}_v).
\]

\textbf{From matrix}: Extract angle $\theta =
\arccos((\trace(\mathbf{C})-1)/2)$, then $\mathbf{k}$ from
skew-symmetric part. Quaternion: $q_0 = \cos(\theta/2)$,
$\mathbf{q}_v = \mathbf{k} \sin(\theta/2)$.

\textbf{Composition} (Hamilton product):
\[
  \mathbf{q}_1 \circ \mathbf{q}_2 = (q_{10}q_{20} - \mathbf{q}_{1v}
    \cdot \mathbf{q}_{2v}, q_{10}\mathbf{q}_{2v} +
  q_{20}\mathbf{q}_{1v} + \mathbf{q}_{1v} \times \mathbf{q}_{2v}).
\]

\textbf{Inverse}: $\mathbf{q}^{-1} = (q_0, -\mathbf{q}_v)$.

\textbf{Rotate vector}: Treat vector as pure quaternion $(0,
\mathbf{v})$, then $\mathbf{v}' = \mathbf{q} \circ (0,\mathbf{v})
\circ \mathbf{q}^{-1}$ (extract vector part).

\textbf{Time derivative}: $\dot{\mathbf{q}} = \frac{1}{2}
\mathbf{q} \circ (0, \boldsymbol{\omega}) = \frac{1}{2}
\mathbf{E}(\mathbf{q}) \boldsymbol{\omega}$, where $\mathbf{E}$
maps angular velocity.

\ssthl{Real-world tip: Use quaternions for SLERP interpolation in
trajectories; normalize after integration to avoid drift.}

\section{Multi Body Kinematics}

\textbf{Generalized coordinates}
Joint variables
$\mathbf{q} = (q_1, \dots, q_n)^T$
(angles for revolute, displacements for prismatic).

\textbf{End-effector configuration}
$\boldsymbol{\chi}_e = (\boldsymbol{\chi}_{eP}, \boldsymbol{\chi}_{eR})^T$
\\(position + orientation params)

\textbf{Operational/task space}
Subset $\boldsymbol{\chi}_o$ for specific tasks \\
(e.g., position only)

\subsection{Forward Kinematics}

End-effector configuration $\boldsymbol{\chi}_e = f(\mathbf{q})$.
For serial chains: Product of homogeneous transforms
$\mathbf{T}_{0n} = \mathbf{T}_{01} \mathbf{T}_{12} \cdots
\mathbf{T}_{(n-1)n}$

\textbf{Denavit-Hartenberg (DH) params}
Standard for link modeling

Transform $\mathbf{T}_{i-1,i} =$
\[
  \begin{bmatrix} \cos\theta_i & -\sin\theta_i \cos\alpha_i &
    \sin\theta_i \sin\alpha_i & a_i \cos\theta_i \\ \sin\theta_i &
    \cos\theta_i \cos\alpha_i & -\cos\theta_i \sin\alpha_i & a_i
    \sin\theta_i \\ 0 & \sin\alpha_i & \cos\alpha_i & d_i \\ 0 & 0 & 0 & 1
  \end{bmatrix}
\]
Link length: \( a_i \)|
Link twist: \( \alpha_i \)|
Link offset: \( d_i \)|
Joint angle: \( \theta_i \)

\ssthl{Exam hint: For revolute, $\theta_i$ variable; prismatic,
$d_i$ variable. Assign frames with z along joint axis.}

\subsection{Workspace Analysis}

\textbf{Reachable}: All positions end-effector can reach
\\
\textbf{Dexterous}: All poses.

\subsection{Jacobians}

\begin{sstTitleBox}[ForestGreen]{
    Jacobi-Box
  }
  \begin{sstOnlyFrame}[ForestGreen]
    \textbf{Analytical Jacobian}

    \textbf{Differential map} \quad
    $\dot{\chi_e} = J_{eA}(q)\dot{q}$

  \end{sstOnlyFrame}
  \begin{sstOnlyFrame}[ForestGreen]
    \[
      J_{eA} =
      \frac{\partial \chi_e}{\partial q} =
      \begin{bmatrix}
        \frac{\partial \chi_1}{\partial q_1}
        & \dots  &
        \frac{\partial \chi_1}{\partial q_n}
        \\
        \vdots & \ddots & \vdots
        \\
        \frac{\partial \chi_m}{\partial q_1}
        & \dots  &
        \frac{\partial \chi_m}{\partial q_n}
      \end{bmatrix}
    \]
  \end{sstOnlyFrame}
  \begin{sstOnlyFrame}[ForestGreen]
    \textbf{Geometric Jacobian} Maps to end-effector twist $\mathbf{t} =
    \begin{bmatrix} \boldsymbol{\omega} \\ \mathbf{v}
    \end{bmatrix} = \mathbf{J}_G \dot{\mathbf{q}}$. Independent of
    param; differs from analytic in orientation (angular velocity vs.
    param rates). Relation: $\mathbf{J}_{eA} =
    \mathbf{T}(\boldsymbol{\chi}_{eR}) \mathbf{J}_G$, where
    $\mathbf{T}$ maps velocity (e.g., for Euler: $\boldsymbol{\omega} =
    \mathbf{E} \dot{\boldsymbol{\alpha}}$).
  \end{sstOnlyFrame}
  \begin{sstOnlyFrame}[ForestGreen]
    \textbf{Derivation (serial chain)}: Assign DH frames. For joint $i$:

    - \textbf{Revolute}:
    Pos. column $\mathbf{J}_{P,i} =
    {}^{i-1}\mathbf{z}_{i-1} \times ({}^0\mathbf{r}_e -
    {}^0\mathbf{r}_{i-1})$
    \\ Rot. $\mathbf{J}_{O,i} = {}^{i-1}\mathbf{z}_{i-1}$ (in base frame)

    - \textbf{Prismatic}:
    Pos. $\mathbf{J}_{P,i} = {}^{i-1}\mathbf{z}_{i-1}$
    Rot. $\mathbf{J}_{O,i} = \mathbf{0}$

    Total $\mathbf{J}_G =
    \begin{bmatrix} \mathbf{J}_P & \mathbf{J}_O
    \end{bmatrix}^T$ (6xn).
  \end{sstOnlyFrame}
  \begin{sstOnlyFrame}[ForestGreen]
    \textbf{Singularity}: $\det(\mathbf{J}\mathbf{J}^T)=0$ (DOF loss).
    Types: Boundary (workspace edge), internal (e.g., aligned links).
    \\
    Manipulability: $\mu = \sqrt{\det(\mathbf{J}\mathbf{J}^T)}$;
    ellipsoid for velocity/force transmission.
  \end{sstOnlyFrame}
\end{sstTitleBox}

(Example 3R planar Jacobian (pos only): $
  \begin{bmatrix} -l_1 s_1 - l_2 s_{12} - l_3 s_{123} & -l_2 s_{12}
    - l_3 s_{123} & -l_3 s_{123} \\ l_1 c_1 + l_2 c_{12} + l_3
    c_{123} & l_2 c_{12} + l_3 c_{123} & l_3 c_{123}
  \end{bmatrix}$

  \ssthl{Real-world tip: Use manipulability for path planning,\\
  damp near singularities ($\lambda \propto 1/\mu$) to prevent instability}

  \subsection{Velocity in Moving Bodies}

  \textbf{Rigid Body Formulation}
  Point P velocity in frame A:\\
  \[
    {}^\mathcal{A}\mathbf{v}_P =
    {}^\mathcal{A}\mathbf{v}_B +
    {}^\mathcal{A}\boldsymbol{\omega}_{\mathcal{A}\mathcal{B}} \times
    {}^\mathcal{A}\mathbf{r}_{BP} + \mathbf{C}_{\mathcal{A}\mathcal{B}}
    {}^\mathcal{B}\mathbf{v}_{BP}^{\text{rel}}
  \]
  \textbf{Twist vector}
  $\mathbf{t} = (\boldsymbol{\omega}, \mathbf{v})^T$
  propagates via adjoint:
  \[
    \mathbf{t}_i = \text{Ad}_{\mathbf{T}_{i-1,i}} \mathbf{t}_{i-1} +
    \mathbf{e}_i \dot{q}_i,
  \]
  where $\text{Ad}_{\mathbf{T}} =
  \begin{bmatrix} \mathbf{C} & \mathbf{0} \\ \mathbf{S}(\mathbf{r})
    \mathbf{C} & \mathbf{C}
  \end{bmatrix}$ (adjoint map), and unit twist $\mathbf{e}_i = (
  \mathbf{z}_i, \mathbf{0} )^T$ for revolute or $( \mathbf{0},
  \mathbf{z}_i )^T$ for prismatic.

  \section{Inverse Kinematics}

  Main idea: Solve $\mathbf{q} = f^{-1}(\boldsymbol{\chi}_e^\star)$.

  \textbf{Numerical} Newton-Raphson:
  $\mathbf{q}_{k+1} =
  \mathbf{q}_k + \mathbf{J}^{-1} (\boldsymbol{\chi}^\star - f(\mathbf{q}_k))$

  \textbf{Velocity level}\quad
  $\dot{\mathbf{q}}
  = \mathbf{J}^\dagger \dot{\boldsymbol{\chi}}_e
  + (\mathbf{I} - \mathbf{J}^\dagger \mathbf{J}) \dot{\mathbf{q}}_0$
  \\(pseudo-inverse for redundancy, nullspace optimization)

  \textbf{Singularities}
  Damped least-squares: $\mathbf{J}^\dagger = \mathbf{J}^T
  (\mathbf{J}\mathbf{J}^T + \lambda^2 \mathbf{I})^{-1}$

  \textbf{Redundancy}: $n > m$; min-norm or secondary tasks\\
  (e.g., joint limit avoidance)

  \subsection{Analytical Inverse Kinematics}

  For 2R planar arm (lengths $l_1, l_2$, target $(x,y)$):\\
  $\theta_2 =
  \pm \arccos\left(\frac{x^2 + y^2 - l_1^2 - l_2^2}{2 l_1 l_2}\right)$,\\
  $\theta_1 =
  \arctan(y,x) - \arctan(l_2 \sin\theta_2, l_1 + l_2 \cos\theta_2)$\\
  For 3R: Solve for $\theta_3$ via circle intersection, then reduce to
  2R (multiple solutions; check workspace).

  \ssthl{Solve inverse for 3R, handle multiple solutions/elbow configs}

  \subsection{Multi-Task Control}

  \textbf{Single task}: $\dot{\mathbf{q}} = \mathbf{J}^\dagger
  \dot{\boldsymbol{\chi}}^\star$. \textbf{Stacked}: $\mathbf{J}_s =
  \begin{bmatrix} \mathbf{J}_1 \\ \mathbf{J}_2
  \end{bmatrix}$, $\dot{\mathbf{q}} = \mathbf{J}_s^\dagger
  \begin{bmatrix} \dot{\boldsymbol{\chi}}_1^\star
    \\ \dot{\boldsymbol{\chi}}_2^\star
  \end{bmatrix}$.

  \textbf{Prioritized}:
  \[
    \dot{\mathbf{q}} = \mathbf{J}_1^\dagger
    \dot{\boldsymbol{\chi}}_1^\star + (\mathbf{I} -
    \mathbf{J}_1^\dagger \mathbf{J}_1) \mathbf{J}_2^\dagger
    (\dot{\boldsymbol{\chi}}_2^\star - \mathbf{J}_2
    \mathbf{J}_1^\dagger \dot{\boldsymbol{\chi}}_1^\star).
  \]

  (Null-space projection ensures task 2 doesn't affect task 1.)

  Find $\dot{q}$ for desired task velocity:
  \begin{itemize}
    \item Single task: $\dot{q} = J^{\dagger} v_{task}$.
    \item Hierarchical (null-space): Primary $J_1, v_1$: $\dot{q} =
      J_1^{\dagger} v_1 + (I - J_1^{\dagger} J_1) \dot{q}_{null}$,
      where $\dot{q}_{null} = J_2^{\dagger} (v_2 - J_2 J_1^{\dagger} v_1)$.
    \item Multi-task: $\dot{q} = \sum N_i \dot{q}_i$, $\dot{q}_i =
      (J_i N_i)^+ (v_i^* - J_i \sum_{k<i} \dot{q}_k)$, with $N_i = I
      - \sum_{k<i} J_k^{\dagger} J_k$.
    \item Near singularity: Damped LS $J^* = J^T (JJ^T + \lambda I)^{-1}$.
  \end{itemize}

  \subsubsection{Error Analysis and Trajectories}

  \textbf{Task error}
  $\mathbf{e} = \boldsymbol{\chi}^\star -
  \boldsymbol{\chi}$

  \textbf{Control}
  $\dot{\boldsymbol{\chi}}^\star = \dot{\boldsymbol{\chi}}_d +
  \mathbf{K} \mathbf{e}$
  (resolved rate)

  \textbf{Joint trajectory} Interpolate $\mathbf{q}(t)$\\
  (cubic poly: $q(t) = a_0 + a_1 t + a_2 t^2 + a_3 t^3$; match vel/acc)

  \ssthl{Exam patterns: Design inverse control loop for redundant arm;
  avoid singularities via damping/nullspace.}

